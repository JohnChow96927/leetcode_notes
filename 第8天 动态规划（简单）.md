# 1. I. 斐波那契数列(No.10)

https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/

- 思路：

  1. 特殊情况处理：n=0时返回0，n=1时返回1

  2. 利用斐波那契数列的表达式：

     `F(N) = F(N - 1) + F(N - 2)	(N>1)`

     解决即可

     注意：对(1e9+7)取模后返回

- 完整代码：

  ```python
  class Solution:
      def fib(self, n: int) -> int:
          if n == 0:
              return 0
          if n == 1:
              return 1
          return int((fib(n - 1) + fib(n - 2)) % (1e9+7))
  ```

# 2. II. 青蛙跳台阶问题(No.10)

https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/

- 思路：

  1. 处理特殊情况，0级或1级台阶返回1

  2. 把此问题拆分成每次面对1级或2级台阶有多少种选择

  3. 即numWays(n - 1) + numWays(n - 2)

  4. 递归即可

  5. 本质上和斐波那契数列一样

     注意：对(1e9+7)取模后返回

- 完整代码：

  ```python
  class Solution:
    def numWays(n: int) -> int:
      if n == 0 or n == 1:
          return 1
      return int((numWays(n - 1) + numWays(n - 2)) % (1e9 + 7))
  ```

# 3. 股票的最大利润(No.63)

https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/

- 思路：

  1. 设result初值为0
  2. 从前到后遍历prices数组
  3. 从遍历到的日期切片至最后一天
  4. 取片段中最大值和当前日期价格作差
  5. 如果差值大于result则将此差值赋给result
  6. 循环结束返回result

- 完整代码：

  ```python
  class Solution:
      def maxProfit(prices) -> int:
          result = 0
          n = len(prices)
          for price_index in range(n):
              if max(prices[price_index + 1:]) - prices[price_index] > result:
                  result = max(prices[price_index:]) - prices[price_index]
          return result
  ```

  