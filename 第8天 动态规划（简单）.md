# 1. I. 斐波那契数列(No.10)

https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/

- 思路：

  1. 递归解决时间复杂度过高，放弃

  2. 空间换时间策略

  3. 使用list存储从0位开始的各位斐波那契数

  4. 排除极端情况：n为0或1时直接返回0或1

  5. 置该fib_list初始为[0, 1]

  6. for循环遍历2到n位，每一位append前两位之和的值

  7. 循环结束返回fib_list最后一位对1000000007取模的int结果

     注意：不能用(1e9+7)，会有精度损失

- 完整代码：

  ```python
  class Solution:
      def fib(self, n: int) -> int:
          if n == 0:
              return 0
          if n == 1:
              return 1
          fib_list = [0, 1]
          for i in range(2, n + 1):
              fib_list.append(fib_list[i - 2] + fib_list[i - 1])
          return int(fib_list[-1] % 1000000007)
  ```

# 2. II. 青蛙跳台阶问题(No.10)

https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/

- 思路：

  1. 处理特殊情况，0级或1级台阶返回1

  2. 把此问题拆分成每次面对1级或2级台阶有多少种选择

  3. 即numWays(n - 1) + numWays(n - 2)

  4. 递归即可

  5. 本质上和斐波那契数列一样

     注意：对(1000000007)取模后返回

- 完整代码：

  ```python
  class Solution:
    def numWays(n: int) -> int:
      if n == 0 or n == 1:
          return 1
      return int((numWays(n - 1) + numWays(n - 2)) % (1e9 + 7))
  ```

# 3. 股票的最大利润(No.63)

https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/

- 思路：

  1. 设result初值为0
  2. 从前到后遍历prices数组
  3. 从遍历到的日期切片至最后一天
  4. 取片段中最大值和当前日期价格作差
  5. 如果差值大于result则将此差值赋给result
  6. 循环结束返回result

- 完整代码：

  ```python
  class Solution:
      def maxProfit(prices) -> int:
          result = 0
          n = len(prices)
          for price_index in range(n):
              if max(prices[price_index + 1:]) - prices[price_index] > result:
                  result = max(prices[price_index:]) - prices[price_index]
          return result
  ```

  